---
import "../styles/global.css";
import BottomSheet from "../components/BottomSheet.astro";
import MapPanel from "../components/MapPanel.astro";
import MediaPanel from "../components/MediaPanel.astro";
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <title>MountZoom Live</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
  </head>
  <body class="min-h-screen bg-slate-950 text-slate-100">
    <main class="mx-auto flex w-full max-w-6xl flex-col gap-6 px-4 pb-10 pt-6 sm:px-6 lg:px-10">
      <section class="grid gap-6 lg:grid-cols-[1.35fr_0.9fr]">
        <MediaPanel title="The Lord of the Streams" />
        <MapPanel />
      </section>

      <BottomSheet />
    </main>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <script type="module">
      const LAST_SEEN_ENDPOINT = "/api/last-seen";
      const GPS_ENDPOINT = "/gps/location";
      const OPENWEATHER_API_KEY = "299fbf95adcf65d403987fbec5b80a23";

      const POLL_INTERVAL_MS = 30000;
      const STREAM_PROBE_MS = 10000;
      const GPS_POLL_MS = 10000;
      const WEATHER_POLL_MS = 15 * 60 * 1000;
      const RECONNECT_MESSAGES = [
        "Reconnecting to stream...",
        "Checking tunnel status...",
        "Refreshing live view...",
        "Trying a new connection...",
      ];

      const streamImage = document.getElementById("stream-image");
      const fallbackImage = document.getElementById("fallback-image");
      const offlineBanner = document.getElementById("offline-banner");
      const statusText = document.getElementById("status-text");
      const statusInline = document.getElementById("status-text-inline");
      const statusDot = document.getElementById("status-dot");
      const locationLabel = document.getElementById("location-label");
      const ageMinutes = document.getElementById("age-minutes");
      const lastSeenTime = document.getElementById("last-seen-time");
      const coords = document.getElementById("coords");
      const staleIndicator = document.getElementById("stale-indicator");
      const reconnectBtn = document.getElementById("reconnect-btn");
      const reconnectMessage = document.getElementById("reconnect-message");
      const reconnectRow = document.getElementById("reconnect-row");
      const reconnectMessageWrap = document.getElementById(
        "reconnect-message-wrap"
      );
      const lastSightingPill = document.getElementById("last-sighting-pill");
      const mediaContainer = document.getElementById("media-container");
      const mapContainer = document.getElementById("map-container");
      const weatherLocation = document.getElementById("weather-location");
      const weatherTemp = document.getElementById("weather-temp");
      const weatherDesc = document.getElementById("weather-desc");
      const weatherAlt = document.getElementById("weather-alt");

      let lastSeenData = null;
      let latestGps = null;
      let isOnline = true;
      let mapInstance = null;
      let mapMarker = null;
      let mapIcon = null;
      let pendingMarkerPosition = null;
      let messageIndex = 0;
      let streamHealthy = false;
      let gpsHealthy = false;
      const MAP_ICON_SCALE = 0.2;
      const CAMPER_ICON_URL = "/camper-icon.png";

      const isValidNumber = (value) =>
        typeof value === "number" && Number.isFinite(value);

      const setStatus = (online) => {
        isOnline = online;
        const text = online ? "Online" : "Offline";
        statusText.textContent = text;
        statusInline.textContent = text;
        statusInline.classList.toggle("text-emerald-300", online);
        statusInline.classList.toggle("text-amber-300", !online);
        statusDot.classList.toggle("bg-emerald-400", online);
        statusDot.classList.toggle("bg-amber-400", !online);
        statusDot.classList.toggle(
          "shadow-[0_0_8px_rgba(16,185,129,0.8)]",
          online
        );
        statusDot.classList.toggle(
          "shadow-[0_0_8px_rgba(251,191,36,0.7)]",
          !online
        );
        offlineBanner.classList.toggle("hidden", streamHealthy);
        fallbackImage.classList.toggle("hidden", streamHealthy);
        streamImage.classList.toggle("hidden", !streamHealthy);
        lastSightingPill.classList.toggle("hidden", streamHealthy);
        reconnectRow.classList.toggle("hidden", streamHealthy);
        reconnectMessageWrap.classList.toggle("hidden", streamHealthy);
      };

      const updateOnlineStatus = () => {
        setStatus(Boolean(streamHealthy || gpsHealthy));
      };

      const formatTimestamp = (isoValue) => {
        if (typeof isoValue !== "string") return "--";
        const date = new Date(isoValue);
        if (Number.isNaN(date.getTime())) return isoValue;
        return new Intl.DateTimeFormat("en-NZ", {
          weekday: "short",
          day: "2-digit",
          month: "short",
          year: "numeric",
          hour: "2-digit",
          minute: "2-digit",
          timeZoneName: "short",
        }).format(date);
      };

      const updateLastSeenUI = (data) => {
        if (!data) return;
        locationLabel.textContent = data.locationLabel ?? "Unknown";
        ageMinutes.textContent =
          typeof data.ageMinutes === "number"
            ? Math.round(data.ageMinutes)
            : "--";
        lastSeenTime.textContent = formatTimestamp(data.timestamp);
        lastSeenTime.dataset.raw = data.timestamp ?? "";
        if (isValidNumber(data.lat) && isValidNumber(data.lon)) {
          coords.textContent = `${data.lat.toFixed(5)}, ${data.lon.toFixed(5)}`;
          updateMap(data.lat, data.lon);
        }
        if (data.imageUrl) {
          fallbackImage.src = `/api/last-seen/image?t=${Date.now()}`;
        }
      };

      const updateWeatherUI = (payload) => {
        if (!payload) return;
        const name = payload.name || "MountZoom";
        const temp =
          typeof payload.main?.temp === "number"
            ? `${Math.round(payload.main.temp)}°C`
            : "--";
        const desc =
          Array.isArray(payload.weather) && payload.weather[0]?.description
            ? payload.weather[0].description
            : "--";
        weatherLocation.textContent = name;
        weatherTemp.textContent = temp;
        weatherDesc.textContent = desc;
        if (weatherAlt) {
          weatherAlt.textContent =
            typeof payload.main?.feels_like === "number"
              ? `Feels ${Math.round(payload.main.feels_like)}°C`
              : "";
        }
      };

      const fetchWeather = async (lat, lon) => {
        if (!OPENWEATHER_API_KEY || OPENWEATHER_API_KEY === "REPLACE_ME") {
          return;
        }
        try {
          const url = new URL(
            "https://api.openweathermap.org/data/2.5/weather"
          );
          url.searchParams.set("lat", lat.toString());
          url.searchParams.set("lon", lon.toString());
          url.searchParams.set("units", "metric");
          url.searchParams.set("appid", OPENWEATHER_API_KEY);
          const response = await fetch(url.toString(), { cache: "no-store" });
          if (!response.ok) throw new Error("Weather fetch failed");
          const contentType = response.headers.get("content-type") ?? "";
          if (!contentType.includes("application/json")) {
            throw new Error("Unexpected weather content type");
          }
          const data = await response.json();
          updateWeatherUI(data);
        } catch (error) {
          // Keep existing weather UI if refresh fails.
        }
      };

      const updateMap = (lat, lon) => {
        if (!mapInstance) return;
        const position = [lat, lon];
        mapInstance.setView(position, 12, { animate: true });
        if (mapMarker) {
          mapMarker.setLatLng(position);
          return;
        }
        if (mapIcon) {
          mapMarker = window.L.marker(position, {
            icon: mapIcon,
          }).addTo(mapInstance);
        } else {
          pendingMarkerPosition = position;
        }
      };

      const initMap = () => {
        if (!window.L || mapInstance) return;
        const iconImage = new Image();
        iconImage.src = CAMPER_ICON_URL;
        iconImage.onload = () => {
          const width = Math.round(iconImage.naturalWidth * MAP_ICON_SCALE);
          const height = Math.round(iconImage.naturalHeight * MAP_ICON_SCALE);
          mapIcon = window.L.icon({
            iconUrl: CAMPER_ICON_URL,
            iconSize: [width, height],
            iconAnchor: [Math.round(width / 2), height],
          });
          if (mapMarker) {
            mapMarker.setIcon(mapIcon);
          } else if (pendingMarkerPosition) {
            mapMarker = window.L.marker(pendingMarkerPosition, {
              icon: mapIcon,
            }).addTo(mapInstance);
            pendingMarkerPosition = null;
          }
        };
        iconImage.onerror = () => {
          mapIcon = null;
          if (!mapMarker && pendingMarkerPosition) {
            mapMarker = window.L.marker(pendingMarkerPosition).addTo(
              mapInstance
            );
            pendingMarkerPosition = null;
          }
        };
        mapInstance = window.L.map("map", {
          zoomControl: false,
          attributionControl: false,
        }).setView([-44.45, 171.21], 11);

        window.L.tileLayer(
          "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
          {
            maxZoom: 17,
          }
        ).addTo(mapInstance);

        if (lastSeenData && isValidNumber(lastSeenData.lat)) {
          updateMap(lastSeenData.lat, lastSeenData.lon);
        }

      };

      const fetchGps = async () => {
        try {
          const response = await fetch(GPS_ENDPOINT, { cache: "no-store" });
          if (!response.ok) throw new Error("GPS unavailable");
          const contentType = response.headers.get("content-type") ?? "";
          if (!contentType.includes("application/json")) {
            throw new Error("Unexpected GPS content type");
          }
          const data = await response.json();
          if (!isValidNumber(data.lat) || !isValidNumber(data.lon)) {
            throw new Error("Invalid GPS data");
          }
          latestGps = data;
          gpsHealthy = true;
          updateOnlineStatus();
          updateMap(data.lat, data.lon);
          fetchWeather(data.lat, data.lon);
        } catch (error) {
          gpsHealthy = false;
          updateOnlineStatus();
          if (!streamHealthy && lastSeenData) {
            updateLastSeenUI(lastSeenData);
          }
        }
      };

      const fetchLastSeen = async () => {
        try {
          const response = await fetch(LAST_SEEN_ENDPOINT, {
            cache: "no-store",
          });
          if (!response.ok) throw new Error("Bad response");
          const contentType = response.headers.get("content-type") ?? "";
          if (!contentType.includes("application/json")) {
            throw new Error("Unexpected content type");
          }
          const data = await response.json();
          if (
            !data ||
            typeof data.timestamp !== "string" ||
            typeof data.locationLabel !== "string" ||
            !isValidNumber(data.lat) ||
            !isValidNumber(data.lon)
          ) {
            throw new Error("Invalid last-seen data");
          }
          lastSeenData = data;
          staleIndicator.classList.add("hidden");
          if (!streamHealthy && !gpsHealthy) {
            updateLastSeenUI(data);
          }
        } catch (error) {
          staleIndicator.classList.remove("hidden");
          if (lastSeenData) {
            if (!streamHealthy && !gpsHealthy) {
              updateLastSeenUI(lastSeenData);
            }
          }
        }
      };

      const loadStream = () => {
        streamImage.src = `/stream?t=${Date.now()}`;
      };

      streamImage.addEventListener("error", () => {
        streamHealthy = false;
        updateOnlineStatus();
      });

      streamImage.addEventListener("load", () => {
        streamHealthy = true;
        updateOnlineStatus();
      });

      const getFullscreenElement = () =>
        document.fullscreenElement || document.webkitFullscreenElement;

      const setPseudoFullscreen = (element, enabled) => {
        if (!element) return;
        element.classList.toggle("pseudo-fullscreen", enabled);
        document.body.classList.toggle("no-scroll", enabled);
      };

      const requestFullscreen = (element) => {
        if (!element) return;
        if (element.classList.contains("pseudo-fullscreen")) {
          setPseudoFullscreen(element, false);
          return;
        }
        const request =
          element.requestFullscreen || element.webkitRequestFullscreen;
        const exit = document.exitFullscreen || document.webkitExitFullscreen;
        if (getFullscreenElement()) {
          exit?.call(document);
          return;
        }
        if (request) {
          try {
            const result = request.call(element);
            if (result?.catch) {
              result.catch(() => {
                setPseudoFullscreen(element, true);
              });
            }
            return;
          } catch (error) {
            setPseudoFullscreen(element, true);
            return;
          }
        }
        setPseudoFullscreen(element, true);
      };

      const enableTapFullscreen = (element) => {
        if (!element) return;
        let touchStart = null;
        let touchMoved = false;
        let touchCount = 0;

        element.addEventListener("touchstart", (event) => {
          touchCount = event.touches.length;
          if (touchCount !== 1) return;
          touchMoved = false;
          touchStart = {
            x: event.touches[0].clientX,
            y: event.touches[0].clientY,
          };
        });

        element.addEventListener("touchmove", (event) => {
          if (!touchStart || event.touches.length !== 1) return;
          const dx = Math.abs(event.touches[0].clientX - touchStart.x);
          const dy = Math.abs(event.touches[0].clientY - touchStart.y);
          if (dx > 8 || dy > 8) {
            touchMoved = true;
          }
        });

        element.addEventListener("touchend", () => {
          if (touchCount !== 1) {
            touchStart = null;
            return;
          }
          if (!touchMoved && touchStart) {
            requestFullscreen(element);
          }
          touchStart = null;
          touchMoved = false;
          touchCount = 0;
        });

        element.addEventListener("touchcancel", () => {
          touchStart = null;
          touchMoved = false;
          touchCount = 0;
        });

        element.addEventListener("click", () => {
          requestFullscreen(element);
        });
      };

      enableTapFullscreen(mediaContainer);
      enableTapFullscreen(mapContainer);

      reconnectBtn.addEventListener("click", async () => {
        await fetchLastSeen();
        loadStream();
        await fetchGps();
      });

      const rotateMessage = () => {
        messageIndex = (messageIndex + 1) % RECONNECT_MESSAGES.length;
        reconnectMessage.textContent = RECONNECT_MESSAGES[messageIndex];
      };

      initMap();
      fetchLastSeen();
      fetchGps();
      loadStream();

      setInterval(fetchLastSeen, POLL_INTERVAL_MS);
      setInterval(fetchGps, GPS_POLL_MS);
      setInterval(() => {
        if (latestGps && isValidNumber(latestGps.lat)) {
          fetchWeather(latestGps.lat, latestGps.lon);
        }
      }, WEATHER_POLL_MS);
      setInterval(rotateMessage, 5000);
    </script>
  </body>
</html>
