---
import "../styles/global.css";
import BottomSheet from "../components/BottomSheet.astro";
import MapPanel from "../components/MapPanel.astro";
import MediaPanel from "../components/MediaPanel.astro";
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <title>MountZoom Live</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
  </head>
  <body class="min-h-screen bg-slate-950 text-slate-100">
    <main class="mx-auto flex w-full max-w-6xl flex-col gap-6 px-4 pb-10 pt-6 sm:px-6 lg:px-10">
      <section class="grid gap-6 lg:grid-cols-[1.35fr_0.9fr]">
        <MediaPanel title="The Lord of the Streams" />
        <MapPanel />
      </section>

      <BottomSheet />
    </main>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <script type="module">
      import {
        CommentsApiError,
        createComment,
        getNzTrailId,
        listComments,
      } from "../lib/commentsApi.js";

      const LAST_SEEN_ENDPOINT = "/api/last-seen";
      const GPS_ENDPOINT = "/gps/location";
      const OPENWEATHER_API_KEY = "299fbf95adcf65d403987fbec5b80a23";

      const POLL_INTERVAL_MS = 30000;
      const GPS_POLL_MS = 10000;
      const WEATHER_POLL_MS = 15 * 60 * 1000;
      const FETCH_TIMEOUT_MS = 6000;
      const TRAIL_POLL_SLOW_MS = 120000;
      const TRAIL_WINDOW_STORAGE_KEY = "mzTrailWindow";
      const TRAIL_WINDOWS = ["1h", "6h", "24h", "7d", "30d", "all"];
      const TRAIL_MAX_POINTS = {
        "1h": 600,
        "6h": 900,
        "24h": 1200,
        "7d": 1500,
        "30d": 1800,
        all: 2000,
      };
      const RECONNECT_MESSAGES = [
        "Reconnecting to stream...",
        "Checking tunnel status...",
        "Refreshing live view...",
        "Trying a new connection...",
      ];

      const streamImage = document.getElementById("stream-image");
      const fallbackImage = document.getElementById("fallback-image");
      const offlineBanner = document.getElementById("offline-banner");
      const statusText = document.getElementById("status-text");
      const statusInline = document.getElementById("status-text-inline");
      const statusDot = document.getElementById("status-dot");
      const locationLabel = document.getElementById("location-label");
      const ageMinutes = document.getElementById("age-minutes");
      const lastSeenTime = document.getElementById("last-seen-time");
      const coords = document.getElementById("coords");
      const staleIndicator = document.getElementById("stale-indicator");
      const reconnectBtn = document.getElementById("reconnect-btn");
      const reconnectMessage = document.getElementById("reconnect-message");
      const reconnectRow = document.getElementById("reconnect-row");
      const reconnectMessageWrap = document.getElementById(
        "reconnect-message-wrap"
      );
      const lastSightingPill = document.getElementById("last-sighting-pill");
      const mediaContainer = document.getElementById("media-container");
      const mediaFullscreenBtn = document.getElementById(
        "media-fullscreen-btn"
      );
      const mapContainer = document.getElementById("map-container");
      const mapFullscreenBtn = document.getElementById("map-fullscreen-btn");
      const mapRecenterBtn = document.getElementById("map-recenter-btn");
      const trailWindowButtons = Array.from(
        document.querySelectorAll("[data-trail-window]")
      );
      const bottomsheetTabButtons = Array.from(
        document.querySelectorAll("[data-bottomsheet-tab]")
      );
      const bottomsheetPanels = Array.from(
        document.querySelectorAll("[data-bottomsheet-panel]")
      );
      const trailDistance = document.getElementById("trail-distance");
      const weatherLocation = document.getElementById("weather-location");
      const weatherTemp = document.getElementById("weather-temp");
      const weatherDesc = document.getElementById("weather-desc");
      const weatherFeels = document.getElementById("weather-feels");
      const weatherAlt = document.getElementById("weather-alt");
      const commentsDisplayName = document.getElementById("comments-display-name");
      const commentsChangeNameBtn = document.getElementById(
        "comments-change-name-btn"
      );
      const commentsFeed = document.getElementById("comments-list");
      const commentsLoading = document.getElementById("comments-loading");
      const commentsError = document.getElementById("comments-error");
      const commentsErrorMessage = document.getElementById("comments-error-message");
      const commentsRetryBtn = document.getElementById("comments-retry-btn");
      const commentsEmpty = document.getElementById("comments-empty");
      const commentsForm = document.getElementById("comment-form");
      const commentMessage = document.getElementById("comment-message");
      const commentSubmitBtn = document.getElementById("comment-submit");
      const commentCharCount = document.getElementById("comment-char-count");
      const commentFormStatus = document.getElementById("comment-form-status");
      const commentsLatestView = document.getElementById("comments-latest-view");
      const joinJourneyModal = document.getElementById("join-journey-modal");
      const joinJourneyForm = document.getElementById("join-journey-form");
      const joinDisplayNameInput = document.getElementById("join-display-name");
      const joinNameError = document.getElementById("join-name-error");
      const joinCancelBtn = document.getElementById("join-cancel-btn");
      const snapshotLightbox = document.getElementById("snapshot-lightbox");
      const snapshotLightboxImage = document.getElementById(
        "snapshot-lightbox-image"
      );
      const snapshotLightboxClose = document.getElementById(
        "snapshot-lightbox-close"
      );

      let lastSeenData = null;
      let latestGps = null;
      let isOnline = true;
      let mapInstance = null;
      let mapMarker = null;
      let mapIcon = null;
      let pendingMarkerPosition = null;
      let trailLine = null;
      let messageIndex = 0;
      let streamHealthy = false;
      let gpsHealthy = false;
      let mapHasUserMoved = false;
      const MAP_ICON_SCALE = 0.08;
      const CAMPER_ICON_URL = "/camper-icon.png";
      const EARTH_RADIUS_KM = 6371;
      let pollingTimers = [];
      let trailPollTimer = null;
      let trailWindow = "24h";
      let trailRequestId = 0;
      let streamRetryDelay = 2000;
      let streamRetryTimer = null;
      let activeBottomsheetTab = "status";
      let commentsLoadedTrailId = "";
      let isCommentsLoading = false;
      let commentsState = [];
      let displayName = "";
      let userId = "";
      let locateMarker = null;
      let locateMarkerTimer = null;

      const isValidNumber = (value) =>
        typeof value === "number" && Number.isFinite(value);

      const toRadians = (value) => (value * Math.PI) / 180;

      const getSegmentDistanceKm = (start, end) => {
        const dLat = toRadians(end[0] - start[0]);
        const dLon = toRadians(end[1] - start[1]);
        const startLat = toRadians(start[0]);
        const endLat = toRadians(end[0]);
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(startLat) *
            Math.cos(endLat) *
            Math.sin(dLon / 2) *
            Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return EARTH_RADIUS_KM * c;
      };

      const getTrailDistanceKm = (latlngs) => {
        if (!Array.isArray(latlngs) || latlngs.length < 2) return 0;
        let total = 0;
        for (let i = 1; i < latlngs.length; i += 1) {
          total += getSegmentDistanceKm(latlngs[i - 1], latlngs[i]);
        }
        return total;
      };

      const updateTrailDistanceUI = (distanceKm) => {
        if (!trailDistance) return;
        trailDistance.textContent = `${distanceKm.toFixed(1)} km`;
      };

      const getStoredValue = (key) => {
        try {
          return localStorage.getItem(key) ?? "";
        } catch (error) {
          return "";
        }
      };

      const setStoredValue = (key, value) => {
        try {
          localStorage.setItem(key, value);
        } catch (error) {
          // Ignore storage failures.
        }
      };

      const createUserId = () => {
        if (window.crypto?.randomUUID) return window.crypto.randomUUID();
        return `mz-${Date.now()}-${Math.random().toString(16).slice(2)}`;
      };

      const setBottomsheetTab = (value) => {
        activeBottomsheetTab = value === "comments" ? "comments" : "status";
        bottomsheetTabButtons.forEach((button) => {
          button.classList.toggle(
            "is-active",
            button.dataset.bottomsheetTab === activeBottomsheetTab
          );
        });
        bottomsheetPanels.forEach((panel) => {
          panel.classList.toggle(
            "hidden",
            panel.dataset.bottomsheetPanel !== activeBottomsheetTab
          );
        });
        if (activeBottomsheetTab === "comments") {
          refreshLatestViewPreview();
          if (!displayName) {
            openJoinJourneyModal(false);
          }
          loadComments();
        }
      };

      const setComposerStatus = (message = "", tone = "muted") => {
        if (!commentFormStatus) return;
        commentFormStatus.textContent = message;
        commentFormStatus.classList.remove(
          "text-slate-400",
          "text-amber-200",
          "text-emerald-300"
        );
        if (tone === "error") {
          commentFormStatus.classList.add("text-amber-200");
          return;
        }
        if (tone === "success") {
          commentFormStatus.classList.add("text-emerald-300");
          return;
        }
        commentFormStatus.classList.add("text-slate-400");
      };

      const setPostingState = (isPosting) => {
        if (commentSubmitBtn) {
          commentSubmitBtn.disabled = isPosting;
          commentSubmitBtn.textContent = isPosting ? "Posting..." : "Post comment";
        }
        if (commentMessage) {
          commentMessage.disabled = isPosting;
        }
      };

      const updateCharCount = () => {
        if (!commentCharCount || !commentMessage) return;
        commentCharCount.textContent = `${commentMessage.value.length}/140`;
      };

      const setDisplayName = (value) => {
        displayName = value;
        if (commentsDisplayName) {
          commentsDisplayName.textContent = displayName || "Guest";
        }
      };

      const showJoinNameError = (message = "") => {
        if (!joinNameError) return;
        joinNameError.textContent = message;
      };

      const openJoinJourneyModal = (dismissible = true) => {
        if (!joinJourneyModal) return;
        joinJourneyModal.dataset.dismissible = dismissible ? "true" : "false";
        joinJourneyModal.classList.remove("hidden");
        joinJourneyModal.classList.add("flex");
        if (joinCancelBtn) {
          joinCancelBtn.classList.toggle("hidden", !dismissible);
        }
        if (joinDisplayNameInput) {
          joinDisplayNameInput.value = displayName;
          setTimeout(() => joinDisplayNameInput.focus(), 0);
        }
        showJoinNameError("");
      };

      const closeJoinJourneyModal = () => {
        if (!joinJourneyModal) return;
        joinJourneyModal.classList.add("hidden");
        joinJourneyModal.classList.remove("flex");
        showJoinNameError("");
      };

      const openSnapshotLightbox = (snapshotUrl) => {
        if (!snapshotLightbox || !snapshotLightboxImage) return;
        snapshotLightboxImage.src = snapshotUrl;
        snapshotLightbox.classList.remove("hidden");
        snapshotLightbox.classList.add("flex");
      };

      const closeSnapshotLightbox = () => {
        if (!snapshotLightbox || !snapshotLightboxImage) return;
        snapshotLightbox.classList.add("hidden");
        snapshotLightbox.classList.remove("flex");
        snapshotLightboxImage.src = "";
      };

      const refreshLatestViewPreview = () => {
        if (!commentsLatestView) return;
        commentsLatestView.src = `/api/last-seen/image?t=${Date.now()}`;
      };

      const setCommentsView = (state, message = "") => {
        commentsLoading?.classList.toggle("hidden", state !== "loading");
        commentsError?.classList.toggle("hidden", state !== "error");
        commentsEmpty?.classList.toggle("hidden", state !== "empty");
        commentsFeed?.classList.toggle("hidden", state !== "list");
        if (commentsErrorMessage && message) {
          commentsErrorMessage.textContent = message;
        }
      };

      const formatCommentTime = (value) => {
        if (typeof value !== "string") return "--";
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return "--";
        return new Intl.DateTimeFormat("en-NZ", {
          day: "2-digit",
          month: "short",
          hour: "2-digit",
          minute: "2-digit",
        }).format(date);
      };

      const addLocateMarker = (lat, lon) => {
        if (!mapInstance || !window.L) return;
        if (locateMarker) {
          mapInstance.removeLayer(locateMarker);
          locateMarker = null;
        }
        if (locateMarkerTimer) {
          clearTimeout(locateMarkerTimer);
          locateMarkerTimer = null;
        }
        locateMarker = window.L.circleMarker([lat, lon], {
          radius: 10,
          color: "#fbbf24",
          weight: 2,
          fillColor: "#f59e0b",
          fillOpacity: 0.35,
        }).addTo(mapInstance);
        locateMarkerTimer = setTimeout(() => {
          if (mapInstance && locateMarker) {
            mapInstance.removeLayer(locateMarker);
          }
          locateMarker = null;
          locateMarkerTimer = null;
        }, 8000);
      };

      const renderComments = () => {
        if (!commentsFeed) return;
        commentsFeed.innerHTML = "";
        if (!commentsState.length) {
          setCommentsView("empty");
          return;
        }

        const fragment = document.createDocumentFragment();
        commentsState.forEach((comment) => {
          const item = document.createElement("li");
          item.className =
            "rounded-xl bg-slate-900/70 p-3 ring-1 ring-white/5";

          const header = document.createElement("div");
          header.className = "mb-2 flex items-center justify-between gap-3";
          const nameEl = document.createElement("p");
          nameEl.className = "text-sm font-semibold text-amber-100";
          nameEl.textContent = comment.displayName || "Guest";
          const timeEl = document.createElement("p");
          timeEl.className = "text-xs text-slate-400";
          timeEl.textContent = formatCommentTime(comment.createdAt);
          header.append(nameEl, timeEl);

          const messageEl = document.createElement("p");
          messageEl.className = "whitespace-pre-wrap text-sm text-slate-200";
          messageEl.textContent = comment.message || "";

          const actions = document.createElement("div");
          actions.className = "mt-3 flex flex-wrap items-center gap-2";

          if (isValidNumber(comment.lat) && isValidNumber(comment.lon)) {
            const locateBtn = document.createElement("button");
            locateBtn.type = "button";
            locateBtn.className =
              "inline-flex items-center justify-center rounded-full bg-slate-800 px-3 py-1 text-[11px] font-semibold uppercase tracking-[0.14em] text-slate-200 ring-1 ring-white/10 transition hover:bg-slate-700";
            locateBtn.dataset.commentLocate = "true";
            locateBtn.dataset.lat = String(comment.lat);
            locateBtn.dataset.lon = String(comment.lon);
            locateBtn.textContent = "Locate";
            actions.append(locateBtn);
          }

          if (typeof comment.snapshotUrl === "string" && comment.snapshotUrl) {
            const snapshotBtn = document.createElement("button");
            snapshotBtn.type = "button";
            snapshotBtn.className =
              "inline-flex items-center gap-2 rounded-full bg-amber-300/10 px-2 py-1 text-[11px] font-semibold uppercase tracking-[0.14em] text-amber-200 ring-1 ring-amber-200/30 transition hover:bg-amber-300/20";
            snapshotBtn.dataset.commentSnapshot = "true";
            snapshotBtn.dataset.snapshotUrl = comment.snapshotUrl;

            const thumb = document.createElement("img");
            thumb.src = comment.snapshotUrl;
            thumb.alt = "Comment snapshot thumbnail";
            thumb.loading = "lazy";
            thumb.className = "h-7 w-10 rounded object-cover ring-1 ring-amber-200/25";

            const text = document.createElement("span");
            text.textContent = "View snapshot";

            snapshotBtn.append(thumb, text);
            actions.append(snapshotBtn);
          }

          item.append(header, messageEl, actions);
          fragment.append(item);
        });

        commentsFeed.append(fragment);
        setCommentsView("list");
      };

      const resolveCommentLoadErrorMessage = (status) => {
        if (status === 404) return "Comments aren't available yet.";
        if (status === 401 || status === 403) {
          return "You don't have access to comments.";
        }
        return "Unable to load comments right now. Please retry.";
      };

      const loadComments = async ({ force = false } = {}) => {
        const trailId = getNzTrailId(new Date());
        if (!force && commentsLoadedTrailId === trailId && commentsState.length) {
          return;
        }
        if (isCommentsLoading) return;
        isCommentsLoading = true;
        setCommentsView("loading");
        try {
          const payload = await listComments(trailId, 50);
          commentsState = payload
            .filter((item) => item && typeof item === "object")
            .sort(
              (a, b) =>
                new Date(b.createdAt ?? 0).getTime() -
                new Date(a.createdAt ?? 0).getTime()
            );
          commentsLoadedTrailId = trailId;
          renderComments();
        } catch (error) {
          const status =
            error instanceof CommentsApiError ? error.status : undefined;
          setCommentsView("error", resolveCommentLoadErrorMessage(status));
        } finally {
          isCommentsLoading = false;
        }
      };

      const resolveCommentCoordinates = async () => {
        if (latestGps && isValidNumber(latestGps.lat) && isValidNumber(latestGps.lon)) {
          return { lat: latestGps.lat, lon: latestGps.lon };
        }
        if (
          lastSeenData &&
          isValidNumber(lastSeenData.lat) &&
          isValidNumber(lastSeenData.lon)
        ) {
          return { lat: lastSeenData.lat, lon: lastSeenData.lon };
        }
        const response = await fetchWithTimeout(
          LAST_SEEN_ENDPOINT,
          { cache: "no-store" },
          FETCH_TIMEOUT_MS
        );
        if (!response.ok) {
          throw new Error("Location is currently unavailable.");
        }
        const contentType = response.headers.get("content-type") ?? "";
        if (!contentType.includes("application/json")) {
          throw new Error("Location is currently unavailable.");
        }
        const payload = await response.json();
        if (!isValidNumber(payload.lat) || !isValidNumber(payload.lon)) {
          throw new Error("Location is currently unavailable.");
        }
        return { lat: payload.lat, lon: payload.lon };
      };

      const renderStatus = () => {
        const overallOnline = Boolean(streamHealthy || gpsHealthy);
        const showStream = streamHealthy;
        const showFallback = !streamHealthy && Boolean(lastSeenData);
        isOnline = overallOnline;
        const text = overallOnline ? "Online" : "Offline";
        statusText.textContent = text;
        statusInline.textContent = text;
        statusInline.classList.toggle("text-emerald-300", overallOnline);
        statusInline.classList.toggle("text-amber-300", !overallOnline);
        statusDot.classList.toggle("bg-emerald-400", overallOnline);
        statusDot.classList.toggle("bg-amber-400", !overallOnline);
        statusDot.classList.toggle(
          "shadow-[0_0_8px_rgba(16,185,129,0.8)]",
          overallOnline
        );
        statusDot.classList.toggle(
          "shadow-[0_0_8px_rgba(251,191,36,0.7)]",
          !overallOnline
        );
        offlineBanner.classList.toggle("hidden", overallOnline);
        fallbackImage.classList.toggle("hidden", !showFallback);
        streamImage.classList.toggle("hidden", !showStream);
        lastSightingPill.classList.toggle("hidden", streamHealthy);
        reconnectRow.classList.toggle("hidden", overallOnline);
        reconnectMessageWrap.classList.toggle("hidden", overallOnline);
      };

      const formatTimestamp = (isoValue) => {
        if (typeof isoValue !== "string") return "--";
        const date = new Date(isoValue);
        if (Number.isNaN(date.getTime())) return isoValue;
        return new Intl.DateTimeFormat("en-NZ", {
          weekday: "short",
          day: "2-digit",
          month: "short",
          year: "numeric",
          hour: "2-digit",
          minute: "2-digit",
          timeZoneName: "short",
        }).format(date);
      };

      const updateLastSeenUI = (data) => {
        if (!data) return;
        locationLabel.textContent = data.locationLabel ?? "Unknown";
        ageMinutes.textContent =
          typeof data.ageMinutes === "number"
            ? Math.round(data.ageMinutes)
            : "--";
        lastSeenTime.textContent = formatTimestamp(data.timestamp);
        lastSeenTime.dataset.raw = data.timestamp ?? "";
        if (isValidNumber(data.lat) && isValidNumber(data.lon)) {
          coords.textContent = `${data.lat.toFixed(5)}, ${data.lon.toFixed(5)}`;
          updateMap(data.lat, data.lon);
        }
        if (data.imageUrl) {
          fallbackImage.src = `/api/last-seen/image?t=${Date.now()}`;
          if (activeBottomsheetTab === "comments") {
            refreshLatestViewPreview();
          }
        }
        renderStatus();
      };

      const updateWeatherUI = (payload) => {
        if (!payload) return;
        const name = payload.name || "MountZoom";
        const temp =
          typeof payload.main?.temp === "number"
            ? `${Math.round(payload.main.temp)}°C`
            : "--";
        const desc =
          Array.isArray(payload.weather) && payload.weather[0]?.description
            ? payload.weather[0].description
            : "--";
        weatherLocation.textContent = name;
        weatherTemp.textContent = temp;
        weatherDesc.textContent = desc;
        if (weatherFeels) {
          weatherFeels.textContent =
            typeof payload.main?.feels_like === "number"
              ? `Feels ${Math.round(payload.main.feels_like)}°C`
              : "";
        }
      };

      const fetchWeather = async (lat, lon) => {
        try {
          const url = new URL(
            "https://api.openweathermap.org/data/2.5/weather"
          );
          url.searchParams.set("lat", lat.toString());
          url.searchParams.set("lon", lon.toString());
          url.searchParams.set("units", "metric");
          url.searchParams.set("appid", OPENWEATHER_API_KEY);
          const response = await fetchWithTimeout(
            url.toString(),
            { cache: "no-store" },
            FETCH_TIMEOUT_MS
          );
          if (!response.ok) throw new Error("Weather fetch failed");
          const contentType = response.headers.get("content-type") ?? "";
          if (!contentType.includes("application/json")) {
            throw new Error("Unexpected weather content type");
          }
          const data = await response.json();
          updateWeatherUI(data);
        } catch (error) {
          // Keep existing weather UI if refresh fails.
        }
      };

      const updateMap = (lat, lon) => {
        if (!mapInstance) return;
        const position = [lat, lon];
        if (!mapHasUserMoved) {
          mapInstance.setView(position, 12, { animate: true });
        }
        if (mapMarker) {
          mapMarker.setLatLng(position);
          return;
        }
        if (mapIcon) {
          mapMarker = window.L.marker(position, {
            icon: mapIcon,
          }).addTo(mapInstance);
        } else {
          pendingMarkerPosition = position;
        }
      };

      const initMap = () => {
        if (!window.L || mapInstance) return;
        const iconImage = new Image();
        iconImage.src = CAMPER_ICON_URL;
        iconImage.onload = () => {
          const width = Math.round(iconImage.naturalWidth * MAP_ICON_SCALE);
          const height = Math.round(iconImage.naturalHeight * MAP_ICON_SCALE);
          mapIcon = window.L.icon({
            iconUrl: CAMPER_ICON_URL,
            iconSize: [width, height],
            iconAnchor: [Math.round(width / 2), height],
          });
          if (mapMarker) {
            mapMarker.setIcon(mapIcon);
          } else if (pendingMarkerPosition) {
            mapMarker = window.L.marker(pendingMarkerPosition, {
              icon: mapIcon,
            }).addTo(mapInstance);
            pendingMarkerPosition = null;
          }
        };
        iconImage.onerror = () => {
          mapIcon = null;
          if (!mapMarker && pendingMarkerPosition) {
            mapMarker = window.L.marker(pendingMarkerPosition).addTo(
              mapInstance
            );
            pendingMarkerPosition = null;
          }
        };
        mapInstance = window.L.map("map", {
          zoomControl: false,
          attributionControl: false,
        }).setView([-44.45, 171.21], 11);

        mapInstance.on("dragstart zoomstart", () => {
          mapHasUserMoved = true;
        });

        window.L.tileLayer(
          "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
          {
            maxZoom: 17,
          }
        ).addTo(mapInstance);

        if (lastSeenData && isValidNumber(lastSeenData.lat)) {
          updateMap(lastSeenData.lat, lastSeenData.lon);
        }
      };
      const refreshTrail = async () => {
        if (!mapInstance || !window.L) return;
        const requestId = (trailRequestId += 1);
        try {
          const windowKey = trailWindow;
          const maxPoints =
            TRAIL_MAX_POINTS[windowKey] ?? TRAIL_MAX_POINTS["24h"];
          const url = new URL("/api/trail", window.location.origin);
          url.searchParams.set("window", windowKey);
          url.searchParams.set("maxPoints", maxPoints.toString());
          const response = await fetchWithTimeout(
            url.toString(),
            { cache: "no-store" },
            FETCH_TIMEOUT_MS
          );
          if (!response.ok) return;
          const contentType = response.headers.get("content-type") ?? "";
          if (!contentType.includes("application/json")) return;
          const data = await response.json();
          if (requestId !== trailRequestId) return;
          const points = Array.isArray(data?.points) ? data.points : [];
          const latlngs = points
            .filter(
              (point) => isValidNumber(point.lat) && isValidNumber(point.lon)
            )
            .map((point) => [point.lat, point.lon]);
          updateTrailDistanceUI(getTrailDistanceKm(latlngs));
          if (latlngs.length < 2) return;
          if (!trailLine) {
            trailLine = window.L.polyline(latlngs, {
              weight: 4,
              opacity: 0.8,
              color: "#fbbf24",
            }).addTo(mapInstance);
          } else {
            trailLine.setLatLngs(latlngs);
          }
        } catch (error) {
          // Keep existing trail if refresh fails.
        }
      };

      const fetchWithTimeout = async (url, options = {}, timeoutMs = 5000) => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
        try {
          return await fetch(url, {
            ...options,
            signal: controller.signal,
          });
        } finally {
          clearTimeout(timeoutId);
        }
      };

      const fetchGps = async () => {
        try {
          const response = await fetchWithTimeout(
            GPS_ENDPOINT,
            { cache: "no-store" },
            FETCH_TIMEOUT_MS
          );
          if (!response.ok) throw new Error("GPS unavailable");
          const contentType = response.headers.get("content-type") ?? "";
          if (!contentType.includes("application/json")) {
            throw new Error("Unexpected GPS content type");
          }
          const data = await response.json();
          if (!isValidNumber(data.lat) || !isValidNumber(data.lon)) {
            throw new Error("Invalid GPS data");
          }
          latestGps = data;
          gpsHealthy = true;
          renderStatus();
          updateMap(data.lat, data.lon);
          if (weatherAlt && isValidNumber(data.alt)) {
            weatherAlt.textContent = `${Math.round(data.alt)}m ASL`;
          }
          fetchWeather(data.lat, data.lon);
        } catch (error) {
          gpsHealthy = false;
          renderStatus();
          if (!streamHealthy && lastSeenData) {
            updateLastSeenUI(lastSeenData);
          }
        }
      };

      const fetchLastSeen = async () => {
        try {
          const response = await fetchWithTimeout(
            LAST_SEEN_ENDPOINT,
            { cache: "no-store" },
            FETCH_TIMEOUT_MS
          );
          if (!response.ok) throw new Error("Bad response");
          const contentType = response.headers.get("content-type") ?? "";
          if (!contentType.includes("application/json")) {
            throw new Error("Unexpected content type");
          }
          const data = await response.json();
          if (
            !data ||
            typeof data.timestamp !== "string" ||
            typeof data.locationLabel !== "string" ||
            !isValidNumber(data.lat) ||
            !isValidNumber(data.lon)
          ) {
            throw new Error("Invalid last-seen data");
          }
          lastSeenData = data;
          staleIndicator.classList.add("hidden");
          updateLastSeenUI(data);
        } catch (error) {
          staleIndicator.classList.remove("hidden");
          if (lastSeenData) {
            updateLastSeenUI(lastSeenData);
          }
        }
      };

      const loadStream = () => {
        streamImage.src = `/stream?t=${Date.now()}`;
      };

      streamImage.addEventListener("error", () => {
        streamHealthy = false;
        renderStatus();
        scheduleStreamRetry();
      });

      streamImage.addEventListener("load", () => {
        streamHealthy = true;
        streamRetryDelay = 2000;
        if (streamRetryTimer) {
          clearTimeout(streamRetryTimer);
          streamRetryTimer = null;
        }
        renderStatus();
      });

      const getFullscreenElement = () =>
        document.fullscreenElement || document.webkitFullscreenElement;

      const supportsNativeFullscreen = (element) =>
        Boolean(
          element?.requestFullscreen ||
            element?.webkitRequestFullscreen ||
            document.fullscreenEnabled ||
            document.webkitFullscreenEnabled
        );

      const fullscreenState = {
        element: null,
        mode: null,
      };

      const setPseudoFullscreen = (element, enabled) => {
        if (!element) return;
        element.classList.toggle("pseudo-fullscreen", enabled);
        document.body.classList.toggle("no-scroll", enabled);
        fullscreenState.element = enabled ? element : null;
        fullscreenState.mode = enabled ? "pseudo" : null;
        if (element === mapContainer && mapInstance) {
          setTimeout(() => {
            mapInstance.invalidateSize();
          }, 200);
        }
      };

      const enterFullscreen = (element) => {
        if (!element) return;
        if (fullscreenState.element && fullscreenState.element !== element) {
          exitFullscreen();
        }
        if (supportsNativeFullscreen(element)) {
          const request =
            element.requestFullscreen || element.webkitRequestFullscreen;
          if (request) {
            fullscreenState.element = element;
            fullscreenState.mode = "native";
            const result = request.call(element);
            if (result?.catch) {
              result.catch(() => {
                setPseudoFullscreen(element, true);
              });
            }
            return;
          }
        }
        setPseudoFullscreen(element, true);
      };

      const exitFullscreen = () => {
        if (fullscreenState.mode === "pseudo") {
          setPseudoFullscreen(fullscreenState.element, false);
          return;
        }
        const exit = document.exitFullscreen || document.webkitExitFullscreen;
        if (getFullscreenElement() && exit) {
          exit.call(document);
        }
        fullscreenState.element = null;
        fullscreenState.mode = null;
      };

      const toggleFullscreen = (element) => {
        if (fullscreenState.element === element) {
          exitFullscreen();
        } else {
          enterFullscreen(element);
        }
      };

      document.addEventListener("fullscreenchange", () => {
        if (!getFullscreenElement()) {
          fullscreenState.element = null;
          fullscreenState.mode = null;
        }
        if (mapInstance) {
          setTimeout(() => {
            mapInstance.invalidateSize();
          }, 150);
        }
      });

      mediaFullscreenBtn?.addEventListener("click", () => {
        toggleFullscreen(mediaContainer);
      });

      mapFullscreenBtn?.addEventListener("click", () => {
        toggleFullscreen(mapContainer);
      });

      mapRecenterBtn?.addEventListener("click", () => {
        mapHasUserMoved = false;
        if (latestGps && isValidNumber(latestGps.lat)) {
          mapInstance?.setView([latestGps.lat, latestGps.lon], 12, {
            animate: true,
          });
        } else if (lastSeenData && isValidNumber(lastSeenData.lat)) {
          mapInstance?.setView([lastSeenData.lat, lastSeenData.lon], 12, {
            animate: true,
          });
        }
      });

      const resolveTrailWindow = (value) =>
        TRAIL_WINDOWS.includes(value) ? value : "24h";

      const updateTrailWindowUI = () => {
        trailWindowButtons.forEach((button) => {
          button.classList.toggle(
            "is-active",
            button.dataset.trailWindow === trailWindow
          );
        });
      };

      const getTrailPollInterval = (value) => {
        if (value === "1h" || value === "6h" || value === "24h") {
          return POLL_INTERVAL_MS;
        }
        return TRAIL_POLL_SLOW_MS;
      };

      const startTrailPolling = () => {
        if (trailPollTimer) {
          clearInterval(trailPollTimer);
        }
        trailPollTimer = setInterval(
          refreshTrail,
          getTrailPollInterval(trailWindow)
        );
      };

      const stopTrailPolling = () => {
        if (!trailPollTimer) return;
        clearInterval(trailPollTimer);
        trailPollTimer = null;
      };

      const setTrailWindow = (value, { persist = true } = {}) => {
        const resolved = resolveTrailWindow(value);
        trailWindow = resolved;
        if (persist) {
          try {
            localStorage.setItem(TRAIL_WINDOW_STORAGE_KEY, resolved);
          } catch (error) {
            // Ignore storage failures (private mode or disabled storage).
          }
        }
        updateTrailWindowUI();
      };

      const initTrailControls = () => {
        try {
          const stored = localStorage.getItem(TRAIL_WINDOW_STORAGE_KEY);
          if (stored) {
            trailWindow = resolveTrailWindow(stored);
          } else {
            setTrailWindow("24h");
          }
        } catch (error) {
          trailWindow = resolveTrailWindow(trailWindow);
        }

        updateTrailWindowUI();

        if (!mapContainer || mapContainer.dataset.trailControlsInitialized) {
          return;
        }
        mapContainer.dataset.trailControlsInitialized = "true";
        trailWindowButtons.forEach((button) => {
          if (button.dataset.trailBound) return;
          button.dataset.trailBound = "true";
          button.addEventListener("click", () => {
            const selected = button.dataset.trailWindow;
            if (!selected) return;
            setTrailWindow(selected);
            refreshTrail();
            startTrailPolling();
          });
        });
      };

      const submitComment = async () => {
        if (!commentMessage || !displayName || !userId) {
          setComposerStatus("Set your display name before posting.", "error");
          openJoinJourneyModal(false);
          return;
        }
        const message = commentMessage.value.trim();
        if (!message) {
          setComposerStatus("Add a short comment before posting.", "error");
          return;
        }
        setPostingState(true);
        setComposerStatus("");
        try {
          const { lat, lon } = await resolveCommentCoordinates();
          const trailId = getNzTrailId(new Date());
          const created = await createComment({
            userId,
            displayName,
            message,
            lat,
            lon,
            trailId,
          });
          commentMessage.value = "";
          updateCharCount();
          setComposerStatus("Comment posted.", "success");
          refreshLatestViewPreview();
          commentsState = [created, ...commentsState].sort(
            (a, b) =>
              new Date(b.createdAt ?? 0).getTime() -
              new Date(a.createdAt ?? 0).getTime()
          );
          commentsLoadedTrailId = trailId;
          renderComments();
          commentMessage.focus();
        } catch (error) {
          const status =
            error instanceof CommentsApiError ? error.status : undefined;
          if (status === 401 || status === 403) {
            setComposerStatus("You don't have access to comments.", "error");
          } else if (status === 404) {
            setComposerStatus("Comments aren't available yet.", "error");
          } else {
            setComposerStatus("Unable to post right now. Please retry.", "error");
          }
        } finally {
          setPostingState(false);
        }
      };

      const initComments = () => {
        setDisplayName(getStoredValue("mzDisplayName"));
        userId = getStoredValue("mzUserId");
        if (!userId) {
          userId = createUserId();
          setStoredValue("mzUserId", userId);
        }

        updateCharCount();
        setComposerStatus("");

        bottomsheetTabButtons.forEach((button) => {
          if (button.dataset.bottomsheetBound) return;
          button.dataset.bottomsheetBound = "true";
          button.addEventListener("click", () => {
            setBottomsheetTab(button.dataset.bottomsheetTab);
          });
        });

        commentsChangeNameBtn?.addEventListener("click", () => {
          openJoinJourneyModal(true);
        });

        commentsRetryBtn?.addEventListener("click", () => {
          loadComments({ force: true });
        });

        commentsFeed?.addEventListener("click", (event) => {
          const target = event.target instanceof Element ? event.target : null;
          if (!target) return;
          const locateButton = target.closest("[data-comment-locate]");
          if (locateButton instanceof HTMLElement) {
            const lat = Number(locateButton.dataset.lat);
            const lon = Number(locateButton.dataset.lon);
            if (isValidNumber(lat) && isValidNumber(lon) && mapInstance) {
              mapHasUserMoved = false;
              mapInstance.setView([lat, lon], 12, { animate: true });
              addLocateMarker(lat, lon);
            }
            return;
          }
          const snapshotButton = target.closest("[data-comment-snapshot]");
          if (snapshotButton instanceof HTMLElement) {
            const snapshotUrl = snapshotButton.dataset.snapshotUrl;
            if (snapshotUrl) {
              openSnapshotLightbox(snapshotUrl);
            }
          }
        });

        commentsForm?.addEventListener("submit", async (event) => {
          event.preventDefault();
          await submitComment();
        });

        commentMessage?.addEventListener("input", () => {
          updateCharCount();
          if (commentMessage.value.length <= 140) {
            setComposerStatus("");
          }
        });

        joinJourneyForm?.addEventListener("submit", (event) => {
          event.preventDefault();
          const nextName = joinDisplayNameInput?.value.trim() ?? "";
          if (!nextName) {
            showJoinNameError("Display name is required.");
            return;
          }
          if (nextName.length > 32) {
            showJoinNameError("Display name must be 32 characters or less.");
            return;
          }
          setDisplayName(nextName);
          setStoredValue("mzDisplayName", nextName);
          closeJoinJourneyModal();
          setComposerStatus("");
          commentMessage?.focus();
        });

        joinCancelBtn?.addEventListener("click", () => {
          const dismissible = joinJourneyModal?.dataset.dismissible === "true";
          if (dismissible) {
            closeJoinJourneyModal();
          }
        });

        joinJourneyModal?.addEventListener("click", (event) => {
          if (event.target !== joinJourneyModal) return;
          const dismissible = joinJourneyModal.dataset.dismissible === "true";
          if (dismissible) {
            closeJoinJourneyModal();
          }
        });

        snapshotLightboxClose?.addEventListener("click", () => {
          closeSnapshotLightbox();
        });

        snapshotLightbox?.addEventListener("click", (event) => {
          if (event.target === snapshotLightbox) {
            closeSnapshotLightbox();
          }
        });

        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            closeSnapshotLightbox();
            const dismissible = joinJourneyModal?.dataset.dismissible === "true";
            if (dismissible) {
              closeJoinJourneyModal();
            }
          }
        });

        setBottomsheetTab(activeBottomsheetTab);
      };

      reconnectBtn?.addEventListener("click", async () => {
        await fetchLastSeen();
        loadStream();
        await fetchGps();
      });

      const rotateMessage = () => {
        messageIndex = (messageIndex + 1) % RECONNECT_MESSAGES.length;
        reconnectMessage.textContent = RECONNECT_MESSAGES[messageIndex];
      };

      initMap();
      initTrailControls();
      initComments();
      fetchLastSeen();
      fetchGps();
      loadStream();
      refreshTrail();

      const scheduleStreamRetry = () => {
        if (streamRetryTimer) return;
        streamRetryTimer = setTimeout(() => {
          streamRetryTimer = null;
          if (!streamHealthy) {
            loadStream();
            streamRetryDelay = Math.min(
              Math.round(streamRetryDelay * 1.6),
              60000
            );
          }
        }, streamRetryDelay);
      };

      const startPolling = () => {
        stopPolling();
        pollingTimers = [
          setInterval(fetchLastSeen, POLL_INTERVAL_MS),
          setInterval(fetchGps, GPS_POLL_MS),
          setInterval(() => {
            if (latestGps && isValidNumber(latestGps.lat)) {
              fetchWeather(latestGps.lat, latestGps.lon);
            }
          }, WEATHER_POLL_MS),
          setInterval(rotateMessage, 5000),
        ];
        startTrailPolling();
      };

      const stopPolling = () => {
        pollingTimers.forEach((timer) => clearInterval(timer));
        pollingTimers = [];
        stopTrailPolling();
      };

      window.addEventListener("online", () => {
        loadStream();
        fetchGps();
        fetchLastSeen();
      });

      window.addEventListener("offline", () => {
        streamHealthy = false;
        gpsHealthy = false;
        renderStatus();
      });

      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          stopPolling();
          return;
        }
        startPolling();
        fetchLastSeen();
        fetchGps();
        const isStreamBlank =
          !streamImage?.complete || (streamImage?.naturalWidth ?? 0) === 0;
        if (isStreamBlank) {
          streamHealthy = false;
          renderStatus();
        }
        loadStream();
      });

      startPolling();
    </script>
  </body>
</html>
